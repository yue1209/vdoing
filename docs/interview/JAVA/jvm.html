<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.51" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://vuepress-theme-hope-docs-demo.netlify.app/interview/JAVA/jvm.html"><meta property="og:site_name" content="Magic.*"><meta property="og:title" content="JVM基础"><meta property="og:type" content="article"><meta property="og:updated_time" content="2022-10-02T11:11:09.000Z"><meta property="og:locale" content="zh-CN"><meta property="article:published_time" content="2022-10-02T18:50:29.000Z"><meta property="article:modified_time" content="2022-10-02T11:11:09.000Z"><title>JVM基础 | Magic.*</title><meta name="description" content="vuepress-theme-hope 的文档演示">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/assets/style.e1db1067.css">
    <link rel="modulepreload" href="/assets/app.d88c6737.js"><link rel="modulepreload" href="/assets/jvm.html.ef9757a2.js"><link rel="modulepreload" href="/assets/_plugin-vue_export-helper.cdc0426e.js"><link rel="modulepreload" href="/assets/jvm.html.0826ddf0.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc"><!--[--><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><a href="/" class="brand"><img class="logo" src="/logo.svg" alt="Magic.*"><!----><span class="site-name hide-in-pad">Magic.*</span></a><!----></div><div class="navbar-center"><!----><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/" class="nav-link" aria-label="主页"><span class="icon iconfont icon-home"></span>主页<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="面向简历编程"><span class="title"><span class="icon iconfont icon-discover"></span>面向简历编程</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>JAVA</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/interview/JAVA/java.html" class="nav-link" aria-label="JAVA基础"><!---->JAVA基础<!----></a></li><li class="dropdown-subitem"><a href="/interview/JAVA/juc.html" class="nav-link" aria-label="JUC编程"><!---->JUC编程<!----></a></li><li class="dropdown-subitem"><a aria-current="page" href="/interview/JAVA/jvm.html" class="router-link-active router-link-exact-active nav-link active" aria-label="JVM基础"><!---->JVM基础<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>数据库</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/interview/DB/MySQL.html" class="nav-link" aria-label="MySQL"><!---->MySQL<!----></a></li><li class="dropdown-subitem"><a href="/interview/DB/Redis.html" class="nav-link" aria-label="Redis"><!---->Redis<!----></a></li><li class="dropdown-subitem"><a href="/interview/DB/MongoDB.html" class="nav-link" aria-label="MongoDB"><!---->MongoDB<!----></a></li><li class="dropdown-subitem"><a href="/interview/DB/Elasticsearch.html" class="nav-link" aria-label="Elasticsearch"><!---->Elasticsearch<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>框架</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/interview/FRAMEWORK/Spring.html" class="nav-link" aria-label="Spring"><!---->Spring<!----></a></li><li class="dropdown-subitem"><a href="/interview/FRAMEWORK/SpringMVC.html" class="nav-link" aria-label="SpringMVC"><!---->SpringMVC<!----></a></li><li class="dropdown-subitem"><a href="/interview/FRAMEWORK/SpringBoot.html" class="nav-link" aria-label="SpringBoot"><!---->SpringBoot<!----></a></li><li class="dropdown-subitem"><a href="/interview/FRAMEWORK/SpringCloud.html" class="nav-link" aria-label="SpringCloud"><!---->SpringCloud<!----></a></li><li class="dropdown-subitem"><a href="/interview/FRAMEWORK/MyBatis.html" class="nav-link" aria-label="MyBatis"><!---->MyBatis<!----></a></li><li class="dropdown-subitem"><a href="/interview/FRAMEWORK/Dubbo.html" class="nav-link" aria-label="Dubbo"><!---->Dubbo<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>中间件</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/interview/MIDDLEWARE/MQ_BASE.html" class="nav-link" aria-label="消息队列基础"><!---->消息队列基础<!----></a></li><li class="dropdown-subitem"><a href="/interview/MIDDLEWARE/RabbitMQ.html" class="nav-link" aria-label="RabbitMQ"><!---->RabbitMQ<!----></a></li><li class="dropdown-subitem"><a href="/interview/MIDDLEWARE/RocketMQ.html" class="nav-link" aria-label="RocketMQ"><!---->RocketMQ<!----></a></li><li class="dropdown-subitem"><a href="/interview/MIDDLEWARE/Kafaka.html" class="nav-link" aria-label="Kafaka"><!---->Kafaka<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>优化</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/interview/OPTIMIZE/SQL_OPT.html" class="nav-link" aria-label="SQL优化"><!---->SQL优化<!----></a></li><li class="dropdown-subitem"><a href="/interview/OPTIMIZE/CODE_OPT.html" class="nav-link" aria-label="代码优化"><!---->代码优化<!----></a></li><li class="dropdown-subitem"><a href="/interview/OPTIMIZE/JVM_OPT.html" class="nav-link" aria-label="JVM优化"><!---->JVM优化<!----></a></li><li class="dropdown-subitem"><a href="/interview/OPTIMIZE/TOMCAT_OPT.html" class="nav-link" aria-label="TOMCAT优化"><!---->TOMCAT优化<!----></a></li><li class="dropdown-subitem"><a href="/interview/OPTIMIZE/DATABASE_OPT.html" class="nav-link" aria-label="数据库优化"><!---->数据库优化<!----></a></li><li class="dropdown-subitem"><a href="/interview/OPTIMIZE/INTERFACE_OPT.html" class="nav-link" aria-label="接口性能优化"><!---->接口性能优化<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="数据库"><span class="title"><span class="icon iconfont icon-creative"></span>数据库</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Bar</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/db/bar/baz" class="nav-link" aria-label="/db/bar/baz"><!---->/db/bar/baz<!----></a></li><li class="dropdown-subitem"><a href="/db/bar/" class="nav-link" aria-label="..."><!---->...<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Foo</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/db/foo/ray" class="nav-link" aria-label="/db/foo/ray"><!---->/db/foo/ray<!----></a></li><li class="dropdown-subitem"><a href="/db/foo/" class="nav-link" aria-label="..."><span class="icon iconfont icon-more"></span>...<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="分布式"><span class="title"><span class="icon iconfont icon-creative"></span>分布式</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Bar</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/distributed/bar/baz" class="nav-link" aria-label="/distributed/bar/baz"><!---->/distributed/bar/baz<!----></a></li><li class="dropdown-subitem"><a href="/distributed/bar/" class="nav-link" aria-label="..."><!---->...<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Foo</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/distributed/foo/ray" class="nav-link" aria-label="/distributed/foo/ray"><!---->/distributed/foo/ray<!----></a></li><li class="dropdown-subitem"><a href="/distributed/foo/" class="nav-link" aria-label="..."><span class="icon iconfont icon-more"></span>...<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="源码解析"><span class="title"><span class="icon iconfont icon-creative"></span>源码解析</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Bar</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/sourcecode/bar/baz" class="nav-link" aria-label="/sourcecode/bar/baz"><!---->/sourcecode/bar/baz<!----></a></li><li class="dropdown-subitem"><a href="/sourcecode/bar/" class="nav-link" aria-label="..."><!---->...<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Foo</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/sourcecode/foo/ray" class="nav-link" aria-label="/sourcecode/foo/ray"><!---->/sourcecode/foo/ray<!----></a></li><li class="dropdown-subitem"><a href="/sourcecode/foo/" class="nav-link" aria-label="..."><span class="icon iconfont icon-more"></span>...<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="小技巧"><span class="title"><span class="icon iconfont icon-creative"></span>小技巧</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Bar</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/guide/bar/baz.html" class="nav-link" aria-label="Baz"><span class="icon iconfont icon-info"></span>Baz<!----></a></li><li class="dropdown-subitem"><a href="/guide/bar/" class="nav-link" aria-label="..."><span class="icon iconfont icon-more"></span>...<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Foo</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/guide/foo/ray.html" class="nav-link" aria-label="Ray"><span class="icon iconfont icon-config"></span>Ray<!----></a></li><li class="dropdown-subitem"><a href="/guide/foo/" class="nav-link" aria-label="..."><span class="icon iconfont icon-more"></span>...<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="收藏夹"><span class="title"><span class="icon iconfont icon-creative"></span>收藏夹</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Bar</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/guide/bar/baz.html" class="nav-link" aria-label="Baz"><span class="icon iconfont icon-info"></span>Baz<!----></a></li><li class="dropdown-subitem"><a href="/guide/bar/" class="nav-link" aria-label="..."><span class="icon iconfont icon-more"></span>...<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Foo</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/guide/foo/ray.html" class="nav-link" aria-label="Ray"><span class="icon iconfont icon-config"></span>Ray<!----></a></li><li class="dropdown-subitem"><a href="/guide/foo/" class="nav-link" aria-label="..."><span class="icon iconfont icon-more"></span>...<!----></a></li></ul></li></ul></button></div></div></nav><!----></div><div class="navbar-right"><!----><!----><!----><div class="nav-item hide-in-mobile"><button class="outlook-button" tabindex="-1" ariahidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="outlook-dropdown"><!----></div></button></div><!----><!----><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable active"><!----><span class="title">Java</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a href="/interview/JAVA/java.html" class="nav-link sidebar-link sidebar-page" aria-label="Java基础"><!---->Java基础<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/JAVA/juc.html" class="nav-link sidebar-link sidebar-page" aria-label="JUC编程"><!---->JUC编程<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/interview/JAVA/jvm.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="JVM基础"><!---->JVM基础<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/interview/JAVA/jvm.html#_1-jvm的内存布局" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.JVM的内存布局？"><!---->1.JVM的内存布局？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/JAVA/jvm.html#_2-jvm类加载" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.JVM类加载"><!---->2.JVM类加载<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/interview/JAVA/jvm.html#_2-1类加载机制" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.1类加载机制"><!---->2.1类加载机制<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/JAVA/jvm.html#_2-2类加载器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.2类加载器"><!---->2.2类加载器<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/JAVA/jvm.html#_2-3-类加载模型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.3 类加载模型"><!---->2.3 类加载模型<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/JAVA/jvm.html#_3-双亲委派模型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.双亲委派模型"><!---->3.双亲委派模型<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/interview/JAVA/jvm.html#_3-1介绍" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.1介绍"><!---->3.1介绍<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/JAVA/jvm.html#_3-2-好处" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.2 好处"><!---->3.2 好处<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/JAVA/jvm.html#_4-stw全局停顿" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4. STW全局停顿"><!---->4. STW全局停顿<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/JAVA/jvm.html#_5-垃圾回收算法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.垃圾回收算法"><!---->5.垃圾回收算法<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/interview/JAVA/jvm.html#_5-1标记-清除" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.1标记-清除"><!---->5.1标记-清除<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/JAVA/jvm.html#_5-2复制算法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.2复制算法"><!---->5.2复制算法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/JAVA/jvm.html#_5-3标记-整理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.3标记-整理"><!---->5.3标记-整理<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/JAVA/jvm.html#_5-4-分代收集算法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.4 分代收集算法"><!---->5.4 分代收集算法<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/JAVA/jvm.html#_6-判断对象是否可回收-gc-root" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.判断对象是否可回收(GC ROOT)"><!---->6.判断对象是否可回收(GC ROOT)<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/interview/JAVA/jvm.html#_6-1引用计数器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.1引用计数器"><!---->6.1引用计数器<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/JAVA/jvm.html#_6-2可达性分析-jvm-默认" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.2可达性分析(JVM 默认)"><!---->6.2可达性分析(JVM 默认)<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/JAVA/jvm.html#_7-垃圾回收器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="7.垃圾回收器"><!---->7.垃圾回收器<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/interview/JAVA/jvm.html#_7-1回收器简述" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="7.1回收器简述"><!---->7.1回收器简述<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/JAVA/jvm.html#_7-2cms回收器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="7.2CMS回收器"><!---->7.2CMS回收器<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/JAVA/jvm.html#_7-3-g1回收器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="7.3 G1回收器"><!---->7.3 G1回收器<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/JAVA/jvm.html#_7-3区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="7.3区别"><!---->7.3区别<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/JAVA/jvm.html#_8-gc的流程-对象什么时候会进入老年代" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="8.GC的流程，对象什么时候会进入老年代？"><!---->8.GC的流程，对象什么时候会进入老年代？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/JAVA/jvm.html#频繁fullgc怎么排查" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="频繁FullGC怎么排查？"><!---->频繁FullGC怎么排查？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/JAVA/jvm.html#jvm调优有什么经验吗" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="JVM调优有什么经验吗？"><!---->JVM调优有什么经验吗？<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/interview/JAVA/jvm.html#简单的参数含义" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="简单的参数含义"><!---->简单的参数含义<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/JAVA/jvm.html#调优" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="调优"><!---->调优<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">数据库</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">框架</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">中间件</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">优化</span><span class="arrow right"></span></button><!----></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->JVM基础</h1><div class="page-info"><span class="author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="author-item" href="https://mrhope.site" target="_blank" rel="noopener noreferrer">Mr.yue</a></span><span property="author" content="Mr.yue"></span></span><!----><span class="date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span>2022年10月3日</span><meta property="datePublished" content="2022-10-02T18:50:29.000Z"></span><!----><!----><span class="reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 19 分钟</span><meta property="timeRequired" content="PT19M"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/interview/JAVA/jvm.html#_1-jvm的内存布局" class="router-link-active router-link-exact-active toc-link level2">1.JVM的内存布局？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/JAVA/jvm.html#_2-jvm类加载" class="router-link-active router-link-exact-active toc-link level2">2.JVM类加载</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/interview/JAVA/jvm.html#_2-1类加载机制" class="router-link-active router-link-exact-active toc-link level3">2.1类加载机制</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/JAVA/jvm.html#_2-2类加载器" class="router-link-active router-link-exact-active toc-link level3">2.2类加载器</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/JAVA/jvm.html#_2-3-类加载模型" class="router-link-active router-link-exact-active toc-link level3">2.3 类加载模型</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/JAVA/jvm.html#_3-双亲委派模型" class="router-link-active router-link-exact-active toc-link level2">3.双亲委派模型</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/interview/JAVA/jvm.html#_3-1介绍" class="router-link-active router-link-exact-active toc-link level3">3.1介绍</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/JAVA/jvm.html#_3-2-好处" class="router-link-active router-link-exact-active toc-link level3">3.2 好处</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/JAVA/jvm.html#_4-stw全局停顿" class="router-link-active router-link-exact-active toc-link level2">4. STW全局停顿</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/JAVA/jvm.html#_5-垃圾回收算法" class="router-link-active router-link-exact-active toc-link level2">5.垃圾回收算法</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/interview/JAVA/jvm.html#_5-1标记-清除" class="router-link-active router-link-exact-active toc-link level3">5.1标记-清除</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/JAVA/jvm.html#_5-2复制算法" class="router-link-active router-link-exact-active toc-link level3">5.2复制算法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/JAVA/jvm.html#_5-3标记-整理" class="router-link-active router-link-exact-active toc-link level3">5.3标记-整理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/JAVA/jvm.html#_5-4-分代收集算法" class="router-link-active router-link-exact-active toc-link level3">5.4 分代收集算法</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/JAVA/jvm.html#_6-判断对象是否可回收-gc-root" class="router-link-active router-link-exact-active toc-link level2">6.判断对象是否可回收(GC ROOT)</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/interview/JAVA/jvm.html#_6-1引用计数器" class="router-link-active router-link-exact-active toc-link level3">6.1引用计数器</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/JAVA/jvm.html#_6-2可达性分析-jvm-默认" class="router-link-active router-link-exact-active toc-link level3">6.2可达性分析(JVM 默认)</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/JAVA/jvm.html#_7-垃圾回收器" class="router-link-active router-link-exact-active toc-link level2">7.垃圾回收器</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/interview/JAVA/jvm.html#_7-1回收器简述" class="router-link-active router-link-exact-active toc-link level3">7.1回收器简述</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/JAVA/jvm.html#_7-2cms回收器" class="router-link-active router-link-exact-active toc-link level3">7.2CMS回收器</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/JAVA/jvm.html#_7-3-g1回收器" class="router-link-active router-link-exact-active toc-link level3">7.3 G1回收器</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/JAVA/jvm.html#_7-3区别" class="router-link-active router-link-exact-active toc-link level3">7.3区别</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/JAVA/jvm.html#_8-gc的流程-对象什么时候会进入老年代" class="router-link-active router-link-exact-active toc-link level2">8.GC的流程，对象什么时候会进入老年代？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/JAVA/jvm.html#频繁fullgc怎么排查" class="router-link-active router-link-exact-active toc-link level2">频繁FullGC怎么排查？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/JAVA/jvm.html#jvm调优有什么经验吗" class="router-link-active router-link-exact-active toc-link level2">JVM调优有什么经验吗？</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/interview/JAVA/jvm.html#简单的参数含义" class="router-link-active router-link-exact-active toc-link level3">简单的参数含义</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/JAVA/jvm.html#调优" class="router-link-active router-link-exact-active toc-link level3">调优</a></li><!----><!--]--></ul><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><p>https://mp.weixin.qq.com/s/LhnaQk9eVYu4Q27SXrcDkA</p><p>https://www.cnblogs.com/crazymakercircle/p/14365820.html</p><h2 id="_1-jvm的内存布局" tabindex="-1"><a class="header-anchor" href="#_1-jvm的内存布局" aria-hidden="true">#</a> 1.JVM的内存布局？</h2><p><img src="https://gitee.com/yueMagic/img/raw/master/blog/20211115104643.webp" alt="20211115104643"></p><p><img src="https://gitee.com/yueMagic/img/raw/master/blog/20200103213220764.png" alt="img"></p><p>Java虚拟机主要包含几个区域：<strong>堆、栈、元数据、本地方法区、程序计数器</strong></p><p><strong>堆</strong>：堆Java虚拟机中<strong>最大的</strong>一块内存，是线程<strong>共享的</strong>内存区域，基本上所有的对象实例数组都是在堆上分配空间。堆区细分为年轻代和老年代，其中年轻代又分为Eden、S0、S1 3个部分，他们默认的比例是8:1:1的大小。</p><p><strong>栈</strong>：栈是线程<strong>私有的</strong>内存区域，每个方法执行的时候都会在栈创建一个<strong>栈帧</strong>，方法的调用过程就对应着栈的入栈和出栈的过程。每个栈帧的结构又包含局部变量表、操作数栈、动态连接、方法返回地址。</p><p>局部变量表用于存储方法参数和局部变量。当第一个方法被调用的时候，他的参数会被传递至从0开始的连续的局部变量表中。</p><p>操作数栈用于一些字节码指令从局部变量表中传递至操作数栈，也用来准备方法调用的参数以及接收方法返回结果。</p><p>动态连接用于将符号引用表示的方法转换为实际方法的直接引用。</p><p><strong>元数据</strong>：在Java1.7之前，包含方法区的概念，常量池就存在于方法区（永久代）中，而方法区本身是一个逻辑上的概念，在1.7之后则是把常量池移到了堆内，1.8之后移出了永久代的概念(方法区的概念仍然保留)，实现方式则是现在的元数据。它包含类的元信息和运行时常量池。</p><p>Class文件就是类和接口的定义信息。</p><p>运行时常量池就是类和接口的常量池运行时的表现形式。</p><p><strong>本地方法栈</strong>：主要用于执行本地native方法的区域</p><p><strong>程序计数器</strong>：也是线程私有的区域，用于记录当前线程下虚拟机正在执行的字节码的指令地址</p><h2 id="_2-jvm类加载" tabindex="-1"><a class="header-anchor" href="#_2-jvm类加载" aria-hidden="true">#</a> 2.JVM类加载</h2><h3 id="_2-1类加载机制" tabindex="-1"><a class="header-anchor" href="#_2-1类加载机制" aria-hidden="true">#</a> 2.1类加载机制</h3><p><img src="https://gitee.com/yueMagic/img/raw/master/blog/image-20211115235147888.png" alt="image-20211115235147888"></p><p><strong>加载，验证，准备，解析，初始化。</strong></p><p>当虚拟机遇见new关键字时候，实现判断当前类是否已经加载，如果类没有加载，首先执行类的加载机制，加载完成后再为对象分配空间、初始化等。</p><ol><li>首先校验当前类<strong>是否被加载</strong>，如果没有加载，执行类加载机制</li><li>加载：就是从<strong>字节码加载成二进制流</strong>的过程</li><li>验证：当然加载完成之后，当然需要<strong>校验Class文件是否符合虚拟机规范</strong>，跟我们接口请求一样，第一件事情当然是先做个参数校验了</li><li>准备：<strong>为静态变量、常量赋默认值</strong></li><li>解析：把常量池中符号引用(以符号描述引用的目标)替换为直接引用(指向目标的指针或者句柄等)的过程</li><li>初始化：<strong>执行static代码块</strong>(cinit)进行初始化，如果存在父类，先对父类进行初始化</li></ol><p><em>Ps：静态代码块是<strong>绝对线程安全</strong>的，只能隐式被java虚拟机在类加载过程中初始化调用！</em>(此处该有问题static代码块线程安全吗？)</p><p>当类加载完成之后，紧接着就是对象分配内存空间和初始化的过程</p><ol><li>首先为对象分配合适大小的内存空间</li><li>接着为实例变量赋默认值</li><li>设置对象的头信息，对象hash码、GC分代年龄、元数据信息等</li><li>执行构造函数(init)初始化</li></ol><h3 id="_2-2类加载器" tabindex="-1"><a class="header-anchor" href="#_2-2类加载器" aria-hidden="true">#</a> 2.2类加载器</h3><p>通过一个类的<code>全限定名来</code>获取描述此类的二进制字节流”。</p><p>类加载器的主要分为这几种，<strong>启动类加载器，拓展类加载器，程序类加载器。用户自定义类加载器。</strong></p><p>另外的话，判断两个类是否相同，需要判断是否使用同一个类进行加载，如果来自于一个 Class文件，但是不是一个加载器加载的话，那也不是同一个类。</p><p>类加载器自顶向下分为：</p><ol><li>Bootstrap ClassLoader启动类加载器：默认会去加载JAVA_HOME/lib目录下的jar</li><li>Extention ClassLoader扩展类加载器：默认去加载JAVA_HOME/lib/ext目录下的jar</li><li>Application ClassLoader应用程序类加载器：比如我们的web应用，会加载web程序中ClassPath下的类</li><li>User ClassLoader用户自定义类加载器：由用户自己定义</li></ol><h3 id="_2-3-类加载模型" tabindex="-1"><a class="header-anchor" href="#_2-3-类加载模型" aria-hidden="true">#</a> 2.3 类加载模型</h3><p>双亲委派模型</p><h2 id="_3-双亲委派模型" tabindex="-1"><a class="header-anchor" href="#_3-双亲委派模型" aria-hidden="true">#</a> 3.双亲委派模型</h2><h3 id="_3-1介绍" tabindex="-1"><a class="header-anchor" href="#_3-1介绍" aria-hidden="true">#</a> 3.1介绍</h3><p>当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成。（如果加载过，则返回给子加载器）每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。</p><p>加载过程：除了启动类加载器，其余所有的类加载器都有父加载器，他们之间为组合关系。</p><h3 id="_3-2-好处" tabindex="-1"><a class="header-anchor" href="#_3-2-好处" aria-hidden="true">#</a> 3.2 好处</h3><p><strong>保证类的唯一性</strong>，<strong>防止内存中出现多份同样的字节码</strong>，<strong>防止某些系统级别的类被篡改</strong>。比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。</p><p>双亲委派模型只是虚拟机的规范，可以通过<strong>继承ClassLoader</strong>类，还要<strong>重写loadClass和findClass</strong>方法来打破双亲委派模型。</p><h2 id="_4-stw全局停顿" tabindex="-1"><a class="header-anchor" href="#_4-stw全局停顿" aria-hidden="true">#</a> 4. STW全局停顿</h2><p>在执行垃圾收集算法时，Java 应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。<strong>「Java 中一种全局暂停现象，全局停顿」</strong>，所有 Java 代码停止，native 代码可以执行，但不能与 JVM 交互。</p><p>因为在 java 应用程序中<strong>引用关系是不断发生变化的</strong>，那么就会有会有很多种情况来导致「<strong>「垃圾标识」</strong>」出错。想想一下如果 Object a 目前是个垃圾，GC 把它标记为垃圾，但是在清除前又有其他对象指向了 Object a，那么此刻 Object a 又不是垃圾了，那么如果没有 STW 就要去无限维护这种关系来去采集正确的信息。再举个例子，到了秋天，道路上洒满了金色的落叶，环卫工人在打扫街道，却永远也无法打扫干净，因为总会有不断的落叶。</p><h2 id="_5-垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#_5-垃圾回收算法" aria-hidden="true">#</a> 5.垃圾回收算法</h2><h3 id="_5-1标记-清除" tabindex="-1"><a class="header-anchor" href="#_5-1标记-清除" aria-hidden="true">#</a> 5.1标记-清除</h3><p>两种方法 ，1.标记垃圾，进行回收 2.标记可存活对象，回收其他空间</p><p>标记完成之后统一回收所有被标记的对象，而由于标记的过程需要<strong>遍历所有的GC ROOT，清除的过程也要遍历堆中所有的对象</strong>，所以标记-清除算法的<strong>效率低下</strong>，同时也带来了<strong>内存碎片</strong>的问题。</p><h3 id="_5-2复制算法" tabindex="-1"><a class="header-anchor" href="#_5-2复制算法" aria-hidden="true">#</a> 5.2复制算法</h3><p>为了解决性能的问题，复制算法应运而生，它将内存分为<strong>大小相等的两块区域</strong>，每次使用其中的一块，当一块内存使用完之后，将还存活的对象拷贝到另外一块内存区域中，然后把当前内存清空，这样性能和内存碎片的问题得以解决。但是同时带来了另外一个问题，<strong>可使用的内存空间缩小了一半</strong>！</p><p>因此，诞生了我们现在的常见的<strong>年轻代+老年代的内存结构：Eden+S0+S1</strong>组成，因为根据IBM的研究显示，98%的对象都是朝生夕死，所以实际上存活的对象并不是很多，完全不需要用到一半内存浪费，所以默认的比例是8:1:1。</p><p>这样，在使用的时候只使<strong>用Eden区和S0S1中的一个，每次都把存活的对象拷贝另外一个未使用的Survivor区，同时清空Eden和使用的Survivor</strong>，这样下来内存的浪费就只有10%了。</p><p>如果最后未使用的Survivor放不下存活的对象，这些对象就进入Old老年代了。</p><p><em>PS：所以有一些初级点的问题会问你为什么要分为Eden区和2个Survior区？有什么作用？就是为了节省内存和解决内存碎片的问题，这些算法都是为了解决问题而产生的，如果理解原因你就不需要死记硬背了</em></p><h3 id="_5-3标记-整理" tabindex="-1"><a class="header-anchor" href="#_5-3标记-整理" aria-hidden="true">#</a> 5.3标记-整理</h3><p>因为进入<strong>老年代的对象都存活率比较高了</strong>，这时候再频繁的复制对性能影响就比较大，而且也不会再有另外的空间进行兜底，所以出现了标记整理算法。<strong>标记出所有的存活对象，让所有存活的对象都向一端移动，然后清理掉边界以外的内存空间。</strong></p><h3 id="_5-4-分代收集算法" tabindex="-1"><a class="header-anchor" href="#_5-4-分代收集算法" aria-hidden="true">#</a> 5.4 分代收集算法</h3><p>分代收集法是目前大部分 JVM 所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代(YoungGeneration)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。</p><ul><li>新生代与复制算法，每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法, 只需要付出少量存活对象的复制成本就可以完成收集</li><li>老年代与标记清楚整理算法，因为老年代对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标记—整理” 算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存。因而采用 Mark-Compact 算法。</li></ul><h2 id="_6-判断对象是否可回收-gc-root" tabindex="-1"><a class="header-anchor" href="#_6-判断对象是否可回收-gc-root" aria-hidden="true">#</a> 6.判断对象是否可回收(GC ROOT)</h2><h3 id="_6-1引用计数器" tabindex="-1"><a class="header-anchor" href="#_6-1引用计数器" aria-hidden="true">#</a> 6.1引用计数器</h3><p>**原理：**给对象添加一个计数器，有一个地方引用它的时候，计数器就加1,失效就减1，当计数器的值为0的时候，那么该对象就是垃圾了。</p><p>**优点：**效率高，实现简单</p><p>**缺点：**如果出现循环引用，就无法回收。比如 a 对象引用了 b 对象，b 对象也引用了 a 对象，a、b 对象却没有再被其他对象所引用了，其实正常来说这两个对象已经是垃圾了，因为没有其他对象在使用了，但是计数器内的数值却不是 0，所以引用计数算法就无法回收它们。</p><p><img src="https://gitee.com/yueMagic/img/raw/master/blog/image-20211116090211197.png" alt="image-20211116090211197"></p><h3 id="_6-2可达性分析-jvm-默认" tabindex="-1"><a class="header-anchor" href="#_6-2可达性分析-jvm-默认" aria-hidden="true">#</a> 6.2可达性分析(JVM 默认)</h3><p><strong>原理：<strong>就是</strong>定义了一系列的根GC Roots</strong>，从 <strong>GC Roots</strong> 开始往下进行搜索，走过的路径我们把它称为 <strong>引用链</strong> ，当一个对象到 <strong>GC Roots</strong> 之间没有任何引用链时，那么这个对象就可以被当做垃圾回收了。</p><p>扩展：首先，<strong>「「为了保证结果的准确性，GC Roots枚举时是要在STW的情况下进行的」」</strong>，但是由于 JAVA 应用越来越大，所以也不能逐个检查每个对象是否为 GC Root，那将消耗大量的时间。一个很自然的想法是，能不能用空间换时间，在某个时候把栈上代表引用的位置全部记录下来，这样到真正 GC 的时候就可以直接读取，而不用再一点一点的扫描了。事实上，大部分主流的虚拟机也正是这么做的，比如 HotSpot ，它使用一种叫做 <strong>「「OopMap」」</strong> 的数据结构来记录这类信息。</p><p><img src="https://gitee.com/yueMagic/img/raw/master/blog/image-20211116090404334.png" alt="image-20211116090404334"></p><p>而可以作为GC ROOT的对象包括：</p><ol><li>栈中引用的对象</li><li>静态变量、常量引用的对象</li><li>本地方法栈native方法引用的对象</li></ol><h2 id="_7-垃圾回收器" tabindex="-1"><a class="header-anchor" href="#_7-垃圾回收器" aria-hidden="true">#</a> 7.垃圾回收器</h2><p><img src="https://gitee.com/yueMagic/img/raw/master/blog/640.png" alt="640"></p><ul><li>新生代回收器：Serial、ParNew、Parallel Scavenge</li><li>老年代回收器：Serial Old、Parallel Old、CMS</li><li>整堆回收器：G1</li></ul><p>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；</p><p>老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p><h3 id="_7-1回收器简述" tabindex="-1"><a class="header-anchor" href="#_7-1回收器简述" aria-hidden="true">#</a> 7.1回收器简述</h3><p><strong>CMS（Concurrent Mark Sweep）</strong>：CMS收集器是以获取最短停顿时间为目标的收集器，相对于其他的收集器STW的时间更短暂，可以并行收集是他的特点，同时他基于标记-清除算法。</p><p><strong>G1（Garbage First）</strong>：DK9的默认垃圾收集器，而且不再区分年轻代和老年代进行回收。</p><p><strong>Serial</strong>：<strong>单线程</strong>版本收集器，使用复制算法负责新生代。回收的时候会STW（Stop The World），也就是进行垃圾回收的时候其他的工作线程都必须暂停。效率低，但内存消耗小。</p><p><strong>ParNew</strong>：Serial的<strong>多线程</strong>版本，在 STW 的时候可以用多个线程去清理垃圾。采用复制算法负责新生代。</p><p><strong>Parallel Scavenge</strong>：可以并行收集的<strong>多线程</strong>垃圾收集器</p><p><strong>Serial Old</strong>：Serial的老年代版本，也是单线程。采用标记整理算法负责老年代。</p><p><strong>Parallel Old</strong>：Parallel Scavenge的老年代版本</p><h3 id="_7-2cms回收器" tabindex="-1"><a class="header-anchor" href="#_7-2cms回收器" aria-hidden="true">#</a> 7.2CMS回收器</h3><p>CMS收集器是以<strong>获取最短停顿时间</strong>为目标的收集器，相对于其他的收集器STW的时间更短暂，对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。可以<strong>并行收集</strong>是他的特点，同时他基于<strong>标记-清除</strong>算法，所以在 gc 的时候回产生大量的内存碎片，当剩余内存<strong>不能满足程序运行要求</strong>时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。整个GC的过程分为4步。是老年代的垃圾回收器，可以配合新生代的Serial和ParNew收集器一起使用。</p><ol><li>初始标记：标记GC ROOT能关联到的对象，需要STW</li><li>并发标记：从GCRoots的直接关联对象开始遍历整个对象图的过程，不需要STW</li><li>重新标记：为了修正并发标记期间，因用户程序继续运作而导致标记产生改变的标记，需要STW</li><li>并发清除：清理删除掉标记阶段判断的已经死亡的对象，不需要STW</li></ol><p>从整个过程来看，并发标记和并发清除的耗时最长，但是不需要停止用户线程，而初始标记和重新标记的耗时较短，但是需要停止用户线程，总体而言，整个过程造成的停顿时间较短，大部分时候是可以和用户线程一起工作的。</p><h3 id="_7-3-g1回收器" tabindex="-1"><a class="header-anchor" href="#_7-3-g1回收器" aria-hidden="true">#</a> 7.3 G1回收器</h3><p>Garbage ﬁrst 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器， G1 收集器两个最突出的改进是： 1.基于标记-整理算法，不产生内存碎片。 2.可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间， 优先回收垃圾最多的区域。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率</p><h3 id="_7-3区别" tabindex="-1"><a class="header-anchor" href="#_7-3区别" aria-hidden="true">#</a> 7.3区别</h3><ul><li>CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用；</li><li>G1收集器收集范围是老年代和新生代，不需要结合其他收集器使用；</li><li>CMS收集器以最小的停顿时间为目标的收集器；</li><li>G1收集器可预测垃圾回收的停顿时间</li><li>CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片</li><li>G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。</li></ul><h2 id="_8-gc的流程-对象什么时候会进入老年代" tabindex="-1"><a class="header-anchor" href="#_8-gc的流程-对象什么时候会进入老年代" aria-hidden="true">#</a> 8.GC的流程，对象什么时候会进入老年代？</h2><ul><li>Java堆 = 老年代 + 新生代</li><li>新生代 = Eden + S0 + S1</li></ul><p>**YGC（年轻代回收）：**一个新的对象来申请内存空间的时候，如果Eden区无法满足内存分配需求时触发YGC。把使用中的Survivor区和Eden区存活对象送到未使用的Survivor区。<strong>大对象</strong>（需要大量连续内存空间的Java对象，如那种很长的字符串）<strong>直接进入老年态</strong>；</p><p>**FGC（完全回收）：**YGC后如果没有足够空间会进入老年代，如果老年代依然无法分配内存，触发FGC清理整个内存堆-包括年轻代和年老代。FGC后依然没有足够内存报OOM。</p><p>YGC之后，存活的对象将会被复制到未使用的Survivor区，如果S区放不下，则直接晋升至老年代。而对于那些一直在Survivor区来回复制的对象，通过-XX：MaxTenuringThreshold配置交换阈值，默认15次，如果超过次数同样进入老年代。</p><p>此外，还有一种动态年龄的判断机制，不需要等到MaxTenuringThreshold就能晋升老年代。如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p><h2 id="频繁fullgc怎么排查" tabindex="-1"><a class="header-anchor" href="#频繁fullgc怎么排查" aria-hidden="true">#</a> 频繁FullGC怎么排查？</h2><p>这种问题最好的办法就是结合有具体的例子举例分析，如果没有就说一般的分析步骤。发生FGC有可能是内存分配不合理，比如Eden区太小，导致对象频繁进入老年代，这时候通过启动参数配置就能看出来，另外有可能就是存在内存泄露，可以通过以下的步骤进行排查：</p><ol><li>jstat -gcutil或者查看gc.log日志，查看内存回收情况</li></ol><p><img src="https://gitee.com/yueMagic/img/raw/master/blog/640" alt="图片"></p><p>S0 S1 分别代表两个Survivor区占比</p><p>E代表Eden区占比，图中可以看到使用78%</p><p>O代表老年代，M代表元空间，YGC发生54次，YGCT代表YGC累计耗时，GCT代表GC累计耗时。</p><p>[GC [FGC 开头代表垃圾回收的类型</p><p>PSYoungGen: 6130K-&gt;6130K(9216K)] 12274K-&gt;14330K(19456K), 0.0034895 secs代表YGC前后内存使用情况</p><p>Times: user=0.02 sys=0.00, real=0.00 secs，user表示用户态消耗的CPU时间，sys表示内核态消耗的CPU时间，real表示各种墙时钟的等待时间</p><p>这两张图只是举例并没有关联关系，比如你从图里面看能到是否进行FGC，FGC的时间花费多长，GC后老年代，年轻代内存是否有减少，得到一些初步的情况来做出判断。</p><ol><li>dump出内存文件在具体分析，比如通过jmap命令jmap -dump:format=b,file=dumpfile pid，导出之后再通过<strong>Eclipse Memory Analyzer</strong>等工具进行分析，定位到代码，修复</li></ol><p>这里还会可能存在一个提问的点，比如CPU飙高，同时FGC怎么办？办法比较类似</p><ol><li>找到当前进程的pid，top -p pid -H 查看资源占用，找到线程</li><li>printf “%x\n” pid，把线程pid转为16进制，比如0x32d</li><li>jstack pid|grep -A 10 0x32d查看线程的堆栈日志，还找不到问题继续</li><li>dump出内存文件用MAT等工具进行分析，定位到代码，修复</li></ol><h2 id="jvm调优有什么经验吗" tabindex="-1"><a class="header-anchor" href="#jvm调优有什么经验吗" aria-hidden="true">#</a> JVM调优有什么经验吗？</h2><p>要明白一点，所有的调优的目的都是为了用更小的硬件成本达到更高的吞吐，JVM的调优也是一样，通过对垃圾收集器和内存分配的调优达到性能的最佳。</p><h3 id="简单的参数含义" tabindex="-1"><a class="header-anchor" href="#简单的参数含义" aria-hidden="true">#</a> 简单的参数含义</h3><p>首先，需要知道几个主要的参数含义。</p><ol><li>-Xms设置初始堆的大小，-Xmx设置最大堆的大小</li><li>-XX:NewSize年轻代大小，-XX:MaxNewSize年轻代最大值，-Xmn则是相当于同时配置-XX:NewSize和-XX:MaxNewSize为一样的值</li><li>-XX:NewRatio设置年轻代和年老代的比值，如果为3，表示年轻代与老年代比值为1:3，默认值为2</li><li>-XX:SurvivorRatio年轻代和两个Survivor的比值，默认8，代表比值为8:1:1</li><li>-XX:PretenureSizeThreshold 当创建的对象超过指定大小时，直接把对象分配在老年代。</li><li>-XX:MaxTenuringThreshold设定对象在Survivor复制的最大年龄阈值，超过阈值转移到老年代</li><li>-XX:MaxDirectMemorySize当Direct ByteBuffer分配的堆外内存到达指定大小后，即触发Full GC</li></ol><h3 id="调优" tabindex="-1"><a class="header-anchor" href="#调优" aria-hidden="true">#</a> 调优</h3><ol><li>为了打印日志方便排查问题最好开启GC日志，开启GC日志对性能影响微乎其微，但是能帮助我们快速排查定位问题。-XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:gc.log</li><li>一般设置-Xms=-Xmx，这样可以获得固定大小的堆内存，减少GC的次数和耗时，可以使得堆相对稳定</li><li>-XX:+HeapDumpOnOutOfMemoryError让JVM在发生内存溢出的时候自动生成内存快照，方便排查问题</li><li>-Xmn设置新生代的大小，太小会增加YGC，太大会减小老年代大小，一般设置为整个堆的1/4到1/3</li><li>设置-XX:+DisableExplicitGC禁止系统System.gc()，防止手动误触发FGC造成问题</li></ol></div><!----><footer class="page-meta"><!----><div class="meta-item update-time"><span class="label">上次编辑于: </span><!----></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: 498420540@qq.com">yue</span><!--]--><!--]--></div></footer><nav class="page-nav"><a href="/interview/JAVA/juc.html" class="nav-link prev" aria-label="JUC编程"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><!---->JUC编程</div></a><!----></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer">Default footer</div><div class="copyright">Copyright © 2022 Mr.yue</div></footer><!--]--></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app.d88c6737.js" defer></script>
  </body>
</html>
