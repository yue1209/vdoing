---
title: JVM基础
date: 2022-10-02 18:50:29
categories:
  - interview
  - Java
tags:
  - 
---
https://mp.weixin.qq.com/s/LhnaQk9eVYu4Q27SXrcDkA

https://www.cnblogs.com/crazymakercircle/p/14365820.html

## 1.JVM的内存布局？

![20211115104643](https://gitee.com/yueMagic/img/raw/master/blog/20211115104643.webp)

![img](https://gitee.com/yueMagic/img/raw/master/blog/20200103213220764.png)

Java虚拟机主要包含几个区域：**堆、栈、元数据、本地方法区、程序计数器**

**堆**：堆Java虚拟机中**最大的**一块内存，是线程**共享的**内存区域，基本上所有的对象实例数组都是在堆上分配空间。堆区细分为年轻代和老年代，其中年轻代又分为Eden、S0、S1 3个部分，他们默认的比例是8:1:1的大小。

**栈**：栈是线程**私有的**内存区域，每个方法执行的时候都会在栈创建一个**栈帧**，方法的调用过程就对应着栈的入栈和出栈的过程。每个栈帧的结构又包含局部变量表、操作数栈、动态连接、方法返回地址。

局部变量表用于存储方法参数和局部变量。当第一个方法被调用的时候，他的参数会被传递至从0开始的连续的局部变量表中。

操作数栈用于一些字节码指令从局部变量表中传递至操作数栈，也用来准备方法调用的参数以及接收方法返回结果。

动态连接用于将符号引用表示的方法转换为实际方法的直接引用。

**元数据**：在Java1.7之前，包含方法区的概念，常量池就存在于方法区（永久代）中，而方法区本身是一个逻辑上的概念，在1.7之后则是把常量池移到了堆内，1.8之后移出了永久代的概念(方法区的概念仍然保留)，实现方式则是现在的元数据。它包含类的元信息和运行时常量池。

Class文件就是类和接口的定义信息。

运行时常量池就是类和接口的常量池运行时的表现形式。

**本地方法栈**：主要用于执行本地native方法的区域

**程序计数器**：也是线程私有的区域，用于记录当前线程下虚拟机正在执行的字节码的指令地址

## 2.JVM类加载

### 2.1类加载机制

![image-20211115235147888](https://gitee.com/yueMagic/img/raw/master/blog/image-20211115235147888.png)

**加载，验证，准备，解析，初始化。**

当虚拟机遇见new关键字时候，实现判断当前类是否已经加载，如果类没有加载，首先执行类的加载机制，加载完成后再为对象分配空间、初始化等。

1. 首先校验当前类**是否被加载**，如果没有加载，执行类加载机制
2. 加载：就是从**字节码加载成二进制流**的过程
3. 验证：当然加载完成之后，当然需要**校验Class文件是否符合虚拟机规范**，跟我们接口请求一样，第一件事情当然是先做个参数校验了
4. 准备：**为静态变量、常量赋默认值**
5. 解析：把常量池中符号引用(以符号描述引用的目标)替换为直接引用(指向目标的指针或者句柄等)的过程
6. 初始化：**执行static代码块**(cinit)进行初始化，如果存在父类，先对父类进行初始化

*Ps：静态代码块是**绝对线程安全**的，只能隐式被java虚拟机在类加载过程中初始化调用！*(此处该有问题static代码块线程安全吗？)

当类加载完成之后，紧接着就是对象分配内存空间和初始化的过程

1. 首先为对象分配合适大小的内存空间
2. 接着为实例变量赋默认值
3. 设置对象的头信息，对象hash码、GC分代年龄、元数据信息等
4. 执行构造函数(init)初始化

### 2.2类加载器

通过一个类的`全限定名来`获取描述此类的二进制字节流”。

类加载器的主要分为这几种，**启动类加载器，拓展类加载器，程序类加载器。用户自定义类加载器。**

另外的话，判断两个类是否相同，需要判断是否使用同一个类进行加载，如果来自于一个 Class文件，但是不是一个加载器加载的话，那也不是同一个类。

类加载器自顶向下分为：

1. Bootstrap ClassLoader启动类加载器：默认会去加载JAVA_HOME/lib目录下的jar
2. Extention ClassLoader扩展类加载器：默认去加载JAVA_HOME/lib/ext目录下的jar
3. Application ClassLoader应用程序类加载器：比如我们的web应用，会加载web程序中ClassPath下的类
4. User ClassLoader用户自定义类加载器：由用户自己定义

### 2.3 类加载模型

双亲委派模型

## 3.双亲委派模型

### 3.1介绍

当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成。（如果加载过，则返回给子加载器）每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。

加载过程：除了启动类加载器，其余所有的类加载器都有父加载器，他们之间为组合关系。

### 3.2 好处

**保证类的唯一性**，**防止内存中出现多份同样的字节码**，**防止某些系统级别的类被篡改**。比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。

双亲委派模型只是虚拟机的规范，可以通过**继承ClassLoader**类，还要**重写loadClass和findClass**方法来打破双亲委派模型。

## 4. STW全局停顿

在执行垃圾收集算法时，Java 应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。**「Java 中一种全局暂停现象，全局停顿」**，所有 Java 代码停止，native 代码可以执行，但不能与 JVM 交互。

因为在 java 应用程序中**引用关系是不断发生变化的**，那么就会有会有很多种情况来导致「**「垃圾标识」**」出错。想想一下如果 Object a  目前是个垃圾，GC 把它标记为垃圾，但是在清除前又有其他对象指向了 Object a，那么此刻 Object a 又不是垃圾了，那么如果没有 STW 就要去无限维护这种关系来去采集正确的信息。再举个例子，到了秋天，道路上洒满了金色的落叶，环卫工人在打扫街道，却永远也无法打扫干净，因为总会有不断的落叶。

## 5.垃圾回收算法

###  5.1标记-清除

两种方法 ，1.标记垃圾，进行回收 2.标记可存活对象，回收其他空间 

标记完成之后统一回收所有被标记的对象，而由于标记的过程需要**遍历所有的GC ROOT，清除的过程也要遍历堆中所有的对象**，所以标记-清除算法的**效率低下**，同时也带来了**内存碎片**的问题。

### 5.2复制算法

为了解决性能的问题，复制算法应运而生，它将内存分为**大小相等的两块区域**，每次使用其中的一块，当一块内存使用完之后，将还存活的对象拷贝到另外一块内存区域中，然后把当前内存清空，这样性能和内存碎片的问题得以解决。但是同时带来了另外一个问题，**可使用的内存空间缩小了一半**！

因此，诞生了我们现在的常见的**年轻代+老年代的内存结构：Eden+S0+S1**组成，因为根据IBM的研究显示，98%的对象都是朝生夕死，所以实际上存活的对象并不是很多，完全不需要用到一半内存浪费，所以默认的比例是8:1:1。

这样，在使用的时候只使**用Eden区和S0S1中的一个，每次都把存活的对象拷贝另外一个未使用的Survivor区，同时清空Eden和使用的Survivor**，这样下来内存的浪费就只有10%了。

如果最后未使用的Survivor放不下存活的对象，这些对象就进入Old老年代了。

*PS：所以有一些初级点的问题会问你为什么要分为Eden区和2个Survior区？有什么作用？就是为了节省内存和解决内存碎片的问题，这些算法都是为了解决问题而产生的，如果理解原因你就不需要死记硬背了*

### 5.3标记-整理

因为进入**老年代的对象都存活率比较高了**，这时候再频繁的复制对性能影响就比较大，而且也不会再有另外的空间进行兜底，所以出现了标记整理算法。**标记出所有的存活对象，让所有存活的对象都向一端移动，然后清理掉边界以外的内存空间。**

### 5.4 分代收集算法

分代收集法是目前大部分 JVM 所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代(YoungGeneration)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。

- 新生代与复制算法，每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法, 只需要付出少量存活对象的复制成本就可以完成收集
- 老年代与标记清楚整理算法，因为老年代对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标记—整理” 算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存。因而采用 Mark-Compact 算法。

## 6.判断对象是否可回收(GC ROOT)

### 6.1引用计数器

**原理：**给对象添加一个计数器，有一个地方引用它的时候，计数器就加1,失效就减1，当计数器的值为0的时候，那么该对象就是垃圾了。

**优点：**效率高，实现简单

**缺点：**如果出现循环引用，就无法回收。比如 a 对象引用了 b 对象，b 对象也引用了 a 对象，a、b 对象却没有再被其他对象所引用了，其实正常来说这两个对象已经是垃圾了，因为没有其他对象在使用了，但是计数器内的数值却不是 0，所以引用计数算法就无法回收它们。

![image-20211116090211197](https://gitee.com/yueMagic/img/raw/master/blog/image-20211116090211197.png)

### 6.2可达性分析(JVM 默认)

**原理：**就是**定义了一系列的根GC Roots**，从 **GC Roots** 开始往下进行搜索，走过的路径我们把它称为 **引用链** ，当一个对象到 **GC Roots** 之间没有任何引用链时，那么这个对象就可以被当做垃圾回收了。	

扩展：首先，**「「为了保证结果的准确性，GC Roots枚举时是要在STW的情况下进行的」」**，但是由于 JAVA 应用越来越大，所以也不能逐个检查每个对象是否为 GC Root，那将消耗大量的时间。一个很自然的想法是，能不能用空间换时间，在某个时候把栈上代表引用的位置全部记录下来，这样到真正 GC 的时候就可以直接读取，而不用再一点一点的扫描了。事实上，大部分主流的虚拟机也正是这么做的，比如 HotSpot ，它使用一种叫做 **「「OopMap」」** 的数据结构来记录这类信息。

![image-20211116090404334](https://gitee.com/yueMagic/img/raw/master/blog/image-20211116090404334.png)

而可以作为GC ROOT的对象包括：

1. 栈中引用的对象
2. 静态变量、常量引用的对象
3. 本地方法栈native方法引用的对象

## 7.垃圾回收器

![640](https://gitee.com/yueMagic/img/raw/master/blog/640.png)

- 新生代回收器：Serial、ParNew、Parallel Scavenge
- 老年代回收器：Serial Old、Parallel Old、CMS
- 整堆回收器：G1

新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；

老年代回收器一般采用的是标记-整理的算法进行垃圾回收。

### 7.1回收器简述

**CMS（Concurrent Mark Sweep）**：CMS收集器是以获取最短停顿时间为目标的收集器，相对于其他的收集器STW的时间更短暂，可以并行收集是他的特点，同时他基于标记-清除算法。

**G1（Garbage First）**：DK9的默认垃圾收集器，而且不再区分年轻代和老年代进行回收。

**Serial**：**单线程**版本收集器，使用复制算法负责新生代。回收的时候会STW（Stop The World），也就是进行垃圾回收的时候其他的工作线程都必须暂停。效率低，但内存消耗小。

**ParNew**：Serial的**多线程**版本，在 STW 的时候可以用多个线程去清理垃圾。采用复制算法负责新生代。

**Parallel Scavenge**：可以并行收集的**多线程**垃圾收集器

**Serial Old**：Serial的老年代版本，也是单线程。采用标记整理算法负责老年代。

**Parallel Old**：Parallel Scavenge的老年代版本

### 7.2CMS回收器

CMS收集器是以**获取最短停顿时间**为目标的收集器，相对于其他的收集器STW的时间更短暂，对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。可以**并行收集**是他的特点，同时他基于**标记-清除**算法，所以在 gc 的时候回产生大量的内存碎片，当剩余内存**不能满足程序运行要求**时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。整个GC的过程分为4步。是老年代的垃圾回收器，可以配合新生代的Serial和ParNew收集器一起使用。

1. 初始标记：标记GC ROOT能关联到的对象，需要STW
2. 并发标记：从GCRoots的直接关联对象开始遍历整个对象图的过程，不需要STW
3. 重新标记：为了修正并发标记期间，因用户程序继续运作而导致标记产生改变的标记，需要STW
4. 并发清除：清理删除掉标记阶段判断的已经死亡的对象，不需要STW

从整个过程来看，并发标记和并发清除的耗时最长，但是不需要停止用户线程，而初始标记和重新标记的耗时较短，但是需要停止用户线程，总体而言，整个过程造成的停顿时间较短，大部分时候是可以和用户线程一起工作的。

### 7.3 G1回收器

Garbage ﬁrst 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器， G1 收集器两个最突出的改进是：
1.基于标记-整理算法，不产生内存碎片。
2.可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间， 优先回收垃圾最多的区域。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率

### 7.3区别

- CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用；
- G1收集器收集范围是老年代和新生代，不需要结合其他收集器使用；
- CMS收集器以最小的停顿时间为目标的收集器；
- G1收集器可预测垃圾回收的停顿时间
- CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片
- G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。

## 8.GC的流程，对象什么时候会进入老年代？

- Java堆 = 老年代 + 新生代
- 新生代 = Eden + S0 + S1

**YGC（年轻代回收）：**一个新的对象来申请内存空间的时候，如果Eden区无法满足内存分配需求时触发YGC。把使用中的Survivor区和Eden区存活对象送到未使用的Survivor区。**大对象**（需要大量连续内存空间的Java对象，如那种很长的字符串）**直接进入老年态**；

**FGC（完全回收）：**YGC后如果没有足够空间会进入老年代，如果老年代依然无法分配内存，触发FGC清理整个内存堆-包括年轻代和年老代。FGC后依然没有足够内存报OOM。

YGC之后，存活的对象将会被复制到未使用的Survivor区，如果S区放不下，则直接晋升至老年代。而对于那些一直在Survivor区来回复制的对象，通过-XX：MaxTenuringThreshold配置交换阈值，默认15次，如果超过次数同样进入老年代。

此外，还有一种动态年龄的判断机制，不需要等到MaxTenuringThreshold就能晋升老年代。如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。

## 频繁FullGC怎么排查？

这种问题最好的办法就是结合有具体的例子举例分析，如果没有就说一般的分析步骤。发生FGC有可能是内存分配不合理，比如Eden区太小，导致对象频繁进入老年代，这时候通过启动参数配置就能看出来，另外有可能就是存在内存泄露，可以通过以下的步骤进行排查：

1. jstat -gcutil或者查看gc.log日志，查看内存回收情况

![图片](https://gitee.com/yueMagic/img/raw/master/blog/640)

S0 S1 分别代表两个Survivor区占比

E代表Eden区占比，图中可以看到使用78%

O代表老年代，M代表元空间，YGC发生54次，YGCT代表YGC累计耗时，GCT代表GC累计耗时。

[GC [FGC 开头代表垃圾回收的类型

PSYoungGen: 6130K->6130K(9216K)] 12274K->14330K(19456K), 0.0034895 secs代表YGC前后内存使用情况

Times: user=0.02 sys=0.00, real=0.00 secs，user表示用户态消耗的CPU时间，sys表示内核态消耗的CPU时间，real表示各种墙时钟的等待时间

这两张图只是举例并没有关联关系，比如你从图里面看能到是否进行FGC，FGC的时间花费多长，GC后老年代，年轻代内存是否有减少，得到一些初步的情况来做出判断。

1. dump出内存文件在具体分析，比如通过jmap命令jmap -dump:format=b,file=dumpfile pid，导出之后再通过**Eclipse Memory Analyzer**等工具进行分析，定位到代码，修复

这里还会可能存在一个提问的点，比如CPU飙高，同时FGC怎么办？办法比较类似

1. 找到当前进程的pid，top -p pid -H 查看资源占用，找到线程
2. printf “%x\n” pid，把线程pid转为16进制，比如0x32d
3. jstack pid|grep -A 10 0x32d查看线程的堆栈日志，还找不到问题继续
4. dump出内存文件用MAT等工具进行分析，定位到代码，修复

## JVM调优有什么经验吗？

要明白一点，所有的调优的目的都是为了用更小的硬件成本达到更高的吞吐，JVM的调优也是一样，通过对垃圾收集器和内存分配的调优达到性能的最佳。

### 简单的参数含义

首先，需要知道几个主要的参数含义。

1. -Xms设置初始堆的大小，-Xmx设置最大堆的大小
2. -XX:NewSize年轻代大小，-XX:MaxNewSize年轻代最大值，-Xmn则是相当于同时配置-XX:NewSize和-XX:MaxNewSize为一样的值
3. -XX:NewRatio设置年轻代和年老代的比值，如果为3，表示年轻代与老年代比值为1:3，默认值为2
4. -XX:SurvivorRatio年轻代和两个Survivor的比值，默认8，代表比值为8:1:1
5. -XX:PretenureSizeThreshold 当创建的对象超过指定大小时，直接把对象分配在老年代。
6. -XX:MaxTenuringThreshold设定对象在Survivor复制的最大年龄阈值，超过阈值转移到老年代
7. -XX:MaxDirectMemorySize当Direct ByteBuffer分配的堆外内存到达指定大小后，即触发Full GC

### 调优

1. 为了打印日志方便排查问题最好开启GC日志，开启GC日志对性能影响微乎其微，但是能帮助我们快速排查定位问题。-XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:gc.log
2. 一般设置-Xms=-Xmx，这样可以获得固定大小的堆内存，减少GC的次数和耗时，可以使得堆相对稳定
3. -XX:+HeapDumpOnOutOfMemoryError让JVM在发生内存溢出的时候自动生成内存快照，方便排查问题
4. -Xmn设置新生代的大小，太小会增加YGC，太大会减小老年代大小，一般设置为整个堆的1/4到1/3
5. 设置-XX:+DisableExplicitGC禁止系统System.gc()，防止手动误触发FGC造成问题